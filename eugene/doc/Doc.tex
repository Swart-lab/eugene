\documentclass[a4paper,titlepage]{report}

\usepackage{t1enc}
\usepackage[pdftex]{graphicx}
\usepackage{times}
\usepackage{a4wide}
\usepackage{hyperref}
\pdfcompresslevel=9
\usepackage{fancyvrb}
\usepackage{multind}

\makeindex{CmdFlags}

\parskip 5pt plus 3pt minus 2pt 

\newcommand{\EuGenie}{\textsc{EuG\`ene}}
% comment one of the above line to hide or not the developpers documentation
%\newcommand{\shrink}[1]{}   % hide text
\newcommand{\shrink}[1]{#1} % no effect

\author{Philipe Bardou, Marie-Jos\'ee Cros, Sylvain Foissac, Annick Moisan,Thomas Schiex\\Biometry and AI Dept.\\ INRA Toulouse\\France}

\title{\EuGenie: an open gene finder for eukaryotes}

\begin{document}
\maketitle
\tableofcontents

\chapter{Quick Start}
\section{Annoting a sequence}
Here is a small example followed by a minimal documentation on
\EuGenie\ (the \emph{Arabidopsis thaliana} instanciation of \EuGenie).
For our example, we have used the \texttt{SYNO\_ARATH.fasta} sequence.

\begin{Verbatim}[fontsize=\scriptsize]
> ls seqs/
SYNO_ARATH.fasta
\end{Verbatim}

In order to first collect information on the sequence (splice sites,
translation start predictions\ldots) we will have to use the
\texttt{getsites4eugene.pl} script. This script directly queries the
Netgene2, SPlicePredictor and NetStart web servers. Alternatively, if
you have installed these programs locally, you can use the
\texttt{lgetsites4eugene.pl} script (you must modify it and indicate
the paths to the executables). 

\begin{Verbatim}[fontsize=\scriptsize]
> ./getsites4eugene.pl seqs/SYNO_ARATH.fasta 
started on sam d\'ec 7 13:44:35 CET 2002

processing seqs/SYNO_ARATH.fasta

NetStart [2*1 request(s)]: F1..R1..done
NetGene2 [1   request(s)]: 1..FR..done
SplicePredictor: done
finished on sam d\'ec 7 13:47:14 CET 2002
\end{Verbatim}

The script creates the files that contains information about the
sequence in the same directory as the fasta file itself. The
extensions used are \texttt{.splices} for NetGene2, \texttt{.spliceP}
for SplicePredictor, \texttt{.starts} for NetStart (in each case, a
\texttt{R} is added for the reverse strand). 

We are now ready to use \EuGenie\ on this sequence. Because the
sequence lacks context around the CDS of the gene, we inform \EuGenie\ 
that the prediction should start and end in intergenic mode using the
\texttt{-s} flag. This behavior can also be controlled by all the
\texttt{Prior} parameters in the program parameter file (see
section~\ref{param}).

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE1
\end{Verbatim}

If we want, we may ask for an HTML output using the \texttt{-ph} flag
which also automatically generates a graphical output in PNG files.

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE2
\end{Verbatim}

If the standard output is saved in a file (for example adding '> \texttt{SYNO\_ARATH.html}' at the end of the command line), the HTML file could then be browsed with your favorite browser.  

\section{Using transcribed sequences}

If you want to exploit similarities with cDNA\AE ST sequences, you have
to inform \EuGenie\ of existing simiairities. These similarities
should be available in a file with the \texttt{.est} extension. The
format of this file is described in the EST plugin
section~\ref{plugest}. It can easily be created from an existing FASTA
databank of EST and cDNA using a patched version of \texttt{sim4}. The
patch is provided with \EuGenie.

\begin{Verbatim}[fontsize=\scriptsize]
> sim4 seqs/SYNO_ARATH.fasta cDNA A=6 > seqs/SYNO_ARATH.fasta.est
\end{Verbatim}

With an old dbEST databank completed with the cDNA databank PlantGene,
we get the following file:

\begin{Verbatim}[fontsize=\scriptsize]
> cat seqs/SYNO_ARATH.fasta.est
    32    421 1844 0 0 ATAJ644    1  390
   514    582 1844 0 0 ATAJ644  391  459
   699    809 1844 0 0 ATAJ644  460  570
   914   1018 1844 0 0 ATAJ644  571  675
  1271   1408 1844 0 0 ATAJ644  676  813
  1522   1602 1844 0 0 ATAJ644  814  894
  1694   1771 1844 0 0 ATAJ644  895  972
  1853   1921 1844 0 0 ATAJ644  973 1041
  2014   2088 1844 0 0 ATAJ644 1042 1116
  2181   2264 1844 0 0 ATAJ644 1117 1200
  2360   2446 1844 0 0 ATAJ644 1201 1287
  2712   2882 1844 0 0 ATAJ644 1288 1458
  2966   3092 1844 0 0 ATAJ644 1459 1585
  3189   3447 1844 0 0 ATAJ644 1586 1844
    32    375 347 0 0 N97006    1  347
  3099   3379 297 0 0 AV525988   51  347
  3071   3092 256 0 1 AI994358    1   22
  3189   3421 256 0 1 AI994358   23  256
   658    672 61 0 1 AV521563    1   14
   765    813 61 0 1 AV521563   15   61
\end{Verbatim}

We can now ask \EuGenie\ for a new prediction, including this new
evidence using the \texttt{-d} flag (equivalently, the \texttt{Est}
plugin can be activated by modifying \EuGenie\ parameter file).  When
evidence from transcribed sequences is available, \EuGenie\ will
automatically report in the ;ast column of its output the percentage
of bases of the element (exon, UTR\ldots) which is consistent with the
available evidence. Here, the gene is almost completely covered by the
available transcribed sequences. The \texttt{Est} plugin also mentions
if transcribed sequences are rejected and why. The information from
two transcribed sequences is rejected. The first one because no splice
site has been found near one of the intron border detected vy the EST,
another one because it was inconsistent with a sequence considered as
more reliable.

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE3
\end{Verbatim}

An additional postprocessing can be requested to the plugin using the
\texttt{-E} flag. For each gene predicted, the plugin will analyze
each transcribed sequence matching the gene and report its consistency
with the prediction.

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE4
\end{Verbatim}

One can see that 2 of the 5 transcribed sequences have been filtered.
\texttt{ATAJ644} is an almost full-length cDNA. It covers almost all
the gene, from the position after the ATG to the 3'UTR. At the end,
for each gene predicted, a summary reports that the CDS predicted is
supported by 3273 over 3276 bases (the ATG is missing in all
trannscripts). The transcribed sequence predicted (including the UTR)
is supported for 3416 of its 3444 bases.

\section{Using protein similarities}

If one wants also to exploit similarities with homologous proteins, a
similar file format can be used (see the corresponding plugin). The
plugin can analyze similarities from several databases, each being
associated with a specific ``level''. For each level, a confidence is
defined in \EuGenie's parameter file. Usually, 3 databases are used:
SwissProt, PIR and TrEMBL (from the highest confidence to the
lowest). Each collection of similarity is stored in a file with an
extension \texttt{.blast} followed by the level of the database
(\texttt{ .blast0}, \texttt{.blast1}, ..., \texttt{.blast7}).  The
script used create these files from the output of NCBI-BLASTX is
copyrighted and is therefore not distributed with \EuGenie. It is not
difficult to design another one. Here is an extract from
\texttt{SYNO\_ARATH.fasta.blast0}:

\begin{Verbatim}[fontsize=\scriptsize]
2820 2861 36 3e-08 +3  sp_O07683_SYD_HALSA; 335 348
2972 3088 41 3e-08 +2  sp_O07683_SYD_HALSA; 359 397
3185 3298 113 3e-08 +2  sp_O07683_SYD_HALSA; 398 435
353 418 45 2e-13 +2  sp_O24822_SYD_HALVO; 13 34
1850 1915 67 2e-13 +2  sp_O24822_SYD_HALVO; 202 223
2775 2858 72 2e-13 +3  sp_O24822_SYD_HALVO; 318 345
3191 3280 104 2e-13 +2  sp_O24822_SYD_HALVO; 397 426
353 418 51 7e-12 +2  sp_O26328_SYD_METTH; 21 42
1271 1414 70 7e-12 +2  sp_O26328_SYD_METTH; 141 188
1850 1954 62 7e-12 +2  sp_O26328_SYD_METTH; 210 244
3191 3280 93 7e-12 +2  sp_O26328_SYD_METTH; 401 430
\end{Verbatim}

To exploit this information, the \texttt{-b} flag must be used,
optionally followed by the set of levels to be exploited
(``\texttt{012}'' means level 0, 1 and 2).  We start \EuGenie\ and ask
for both EST and proteic similarities analysis. We again enforce the
use of an intergenic mode on the beginning and end of the sequence.

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE5
\end{Verbatim}

\section{Injecting further information}

Additional user information on the intronic, exonic, intergenic aspect
of the sequence or on specific signals can be injected using a
specific simple langage (see the the user plugin,
section \ref{pluguser}). This plugin is activated using the
\texttt{-U} flag. The plugin will read the file with extension
\texttt{.user}. For example, imagine I know that the 5'UTR of the gene
extends from position2 to 28 I can inject this information in
\EuGenie\ as follows (the \texttt{10.0} gives a strong influence to
this information, see the plugin description):

\begin{Verbatim}[fontsize=\scriptsize]
utr5 f [2..28] 10.0
\end{Verbatim} 

If I use \EuGenie\ with the \texttt{-U} flag (and even without
\texttt{-s}), we get the following prediction:

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE6
\end{Verbatim} 

This type of plugin allows to explore alternative predictions. Eg. one
may wonder what is the optimal prediction if the splice site at
position \texttt{2966} is not used. It suffices to forbid this splice
site using the following user file:

\begin{Verbatim}[fontsize=\scriptsize]
acceptor f 2966 0.0
\end{Verbatim}
and to ask for a new prediction.

\begin{Verbatim}[fontsize=\scriptsize]
EXECUTION_TRACE7
\end{Verbatim}

Other plugins are described in the reference section of this document.






\newpage
\chapter{Reference documentation}

To be executed, \EuGenie\ needs at least one file: this is the so-called 
parameter file.  \EuGenie\ behavior
is entirely controlled by a set of parameters whose default values are
available in this file. These default values can be altered by
editing this file or for some values through flags in the command line (such as
\texttt{-d}, see below). Command line flags override any value in the
parameter file. The name of the parameter file that \EuGenie\ seeks is
obtained by adding the suffix ``\texttt{.par}'' to the name of the
\EuGenie\ command itself.  As it is distributed, \EuGenie\ command's
name is \texttt{EuGeneAS} and accordingly the parameter file is
\texttt{EuGeneAS.par}. If at some point you want to use several
different parameter files, you can simply use symbolic links to the
\texttt{EuGeneAS} binary executable. Using a symbolic link, with a
specific name to call \EuGenie\ will enable you to load a different
parameter file whose name is derived from the symbolic link name by
ading `\texttt{`.par}'' The parameter file is first sought in the
local directory.  If this fails, the value of the environment variable
\texttt{EUGENEDIR} is used as a second possible path.

\EuGenie\ gathers all informations on the FASTA sequences through
so-called ``plugins'' also called ``sensors''. A plugin is a small
software component that can be dynamically loaded and that can inform
\EuGenie\ about likely exonic, intronic, utr, intergenic regions and
about signals in the sequence (either splice sites, translation starts
and stops, transcription starts and stops and possible frameshifts).
Plugins can typically embody Markov models (that characterize exonic,
intronic\ldots regions) or splice site detectors or others.  Available
sensors are stored in the \texttt{PLUGINS} directory and are
dynamically loaded by \EuGenie\ according to the parameters.

The typical call to \EuGenie\ is:

\begin{Verbatim}[fontsize=\small]
EuGeneAS <fasta files>
\end{Verbatim}

where each FASTA file contains one single DNA sequence. In this cas,
the first action of \EuGenie\ is to seek and load the parameter file.
All the parameters in this file are either used by \EuGenie\ or by the
plugins. Each plugin may have its own parameters. The following
section describes all the parameters used by \EuGenie. Information
about the parameters used by plugins is provided in each plugin
section (see section~\ref{plug}).

\section{\EuGenie's parameters}
\label{param}

Here is a list of all the parameters which control \EuGenie's
behavior. When a command line flag exists that can modify the
corresponding parameter, it is indicated.  All the parameters that
control \EuGenie\'s behavior are available in the parameter file. This
file has a relatively strict formatting. Each line can either be a
comment line (the first character in the line must be a \verb # ) or a
parameter definition. Empty lines are not allowed. A parameter
definition is composed of two strings of character. The first one is
the name of the parameter, the second is its value. Everything is case
sensitive. The definition order is not important.

\begin{itemize}
\item \texttt{EuGene.key}: a key code that limit \EuGenie\ in IP space
  and time. If the key is incorrect, EuGene will still work but will
  be limited to less than 6kB long sequences.
  
\item \texttt{EuGene.versionPAR}: specifies the version of the
  parameter file. After having load the parameter file, EuGene checks
  that the parameter file version is consistent with the expected
  version.
  
\item \texttt{EuGene.PluginsDir}: specify the location of the directory
  where plugins could be found (``\texttt{.so}'' files, sensor specific 
  models files); that is the path to the \texttt{PLUGINS} directory.

\item \texttt{EuGene.minEx}, \texttt{EuGene.minIn},
  \texttt{EuGene.minSg}, \texttt{EuGene.minFlow},
  \texttt{EuGene.minConv}, \texttt{EuGene.minDiv},
  \texttt{EuGene.min5Prime}, \texttt{EuGene.min3Prime}: minimum length
  constraints on respectively the length of exons, introns, single
  exon genes, intergenic regions (depending on the orientation of
  surrounding genes), 5'UTR and 3'UTR regions.
  
\item \texttt{EuGene.stopP}: penalty for stopping a gene (traduction).
  
\item \texttt{EuGene.ExonPrior}, \texttt{EuGene.IntronPrior},
  \texttt{EuGene.InterPrior}, \texttt{EuGene.FivePrimePrior},
  \texttt{EuGene.ThreePrimePrior}: prior on the initial/final state of
  prediction. The ``\texttt{-s}'' command line flag can override these
  priors by setting all the non intergenic priors to $0.0$. This
  forces \EuGenie\ to start and and its prediction in intergenic mode.
  
\item \texttt{EuGene.transCodant}, \texttt{EuGene.transIntron},
  \texttt{EuGene.transUTR5}, \texttt{EuGene.transUTR3},
  \texttt{EuGene.transInter}: by default, \EuGenie\ implicit
  distribution on the length of all regions is a flat distribution.
  These parameters allows to use a distribution similar to the
  exponential implicit distribution in basic (non semi-Markovian) HMM.
  This distribution is actually truncated by the minimum lemgth
  constraints.
  
\item \texttt{Output.graph}: if set, requests graphical PNG output.
  This can also be set using the \texttt{-g} command line flag. This
  flag can be followed (without spaces) by a base filename which will
  be completed by the number of the figure + .png extension (possibly,
  start/end positions will be inserted too if -u/-v is used). If the
  filename is omitted, the seq name (w/o the .fasta suffix) is used as
  a basename.
  
\item \texttt{Output.resx}, \texttt{Output.resy}: controls the
  horizontal and vertical resolution of the PNG images generated by
  \EuGenie. 
  
\item \texttt{Output.gfrom}, \texttt{Output.gto}: respectively
  controls which part of the sequence is to be plotted (eg. for
  zooming). The default value for both is $-1$ which corresponds to
  the whole sequence. These parameters can also be set using the
  \texttt{-u} and \texttt{-v} flags.
  
\item \texttt{Output.glen}: controls the number of nucleotides that
  will appear on a single image. The value $-1$ corresponds to a
  default adaptative mechanism which plots min (6000,length to
  visualize). The ``length to visualize'' is computed from the value
  given to \texttt{Output.gfrom} and \texttt{Output.gto}.
  
\item \texttt{Output.golap}: controls how successives PNG images
  overlap. It must be set to the number of overlapping nucleotides
  between 2 successives PNG images. Default is $-1$ which
  heuristically determines this based on resolution and number of nuc.
  per image. This parameter can also be set using the \texttt{-c}
  command line flag.
  
\item \texttt{Output.window}: sets the half-size of the smoothing
  window used to plot the scores.  Default is 48. This does not affect
  prediction, only graphical output. It can be set using the
  \texttt{-w} command line flag.
  
\item \texttt{Output.format}: controls the format of the textual
  outpout. May be \texttt{d} (detailed), \texttt{l} (long), \texttt{s}
  (short), \texttt{h} (html), \texttt{g} (gff) or \texttt{a} (araset
  format). Default is \texttt{l}. This can be overrided using the
  \texttt{-p} command line flag.
  
\item \texttt{Output.offset}: allows to offset the nucleotide position
  of the prediction.  That is, the prediction for nucleotide at
  position $i$ of the given sequence is printed as nucleotide $i+$ the
  offset. Useful to perform prediction on an extracted sequence
  without loosing the original position. CAn also be set using the
  \texttt{-o} command line flag.
  
\item \texttt{Output.normopt}: indicates the way the score are
  normalized accross the possibles states (phase 1,2,3,-1,-2,-3,
  introns and intergenic states).
  \begin{itemize}
  \item 0: no normalization
  \item 1: normalize accross all states
  \item 2: normalize each coding phase w.r.t. to the non coding
    score only.
  \end{itemize}
  Default is 1. Does not affect prediction, only graphical output.
  
\item \texttt{Output.Prefix}: indicates the directory where all non
  stderr/stdout output (eg. PNG images) should go. Default is the
  current directory.
\end{itemize}

\section{Plugins}
\label{plug}

Plugins are small software components that can be dynamically loaded
by \EuGenie. Although it is completely transparent to the end-user,
every plugin loaded by \EuGenie\ must be written in C++ and be a
subclass of the Sensor class. This class provides essentially four
methods:
\begin{itemize}
\item \texttt{Init}: receives as argument the sequence to process (an
  instance of the \texttt{DNASeq} class) and initializes the plugin by
  loading the information needed.
\item \texttt{GiveInfo}: receives as argument the sequence to process
  (an instance of the \texttt{DNASeq} class), a position on the
  sequence and a \texttt{Data} instance. The \texttt{Data}
  data-structure can receive predictions on all signals and contents
  scores know to \EuGenie.
\item \texttt{Plot}: receives as argument the sequence to process (an
  instance of the \texttt{DNASeq} class) and plots all the predictions
  made by the sensor.
\item \texttt{PostAnalyse}: receives as argument the prediction of
  \EuGenie\ and may check it agains its own prediction and report
  support or inconsistencies.
\end{itemize}

The \texttt{Plot} and \texttt{PostAnalyse} methods are usually empty.

\subsection{Loading plugins}

When \EuGenie\ starts, plugins are loaded and instanciated following
parameters in the parameter file. The \texttt{Sensor.*.use} may
activate or desactivate the corresponding sensor (which must be
available in the PLUGINS directory). If the parameter value is set to
\texttt{0} or \texttt{FALSE}, the plugin is not used. If the parameter
value is set to \texttt{TRUE}, then a single instance of the plugin is
loaded. If the parameter is set to an integer value, then this number
of instances of the plugin are created.

Below is the list of minimum plugins which are activated by default by
the \emph{Arabidopsis thaliana} version of \EuGenie.

\begin{Verbatim}
Sensor.Transcript.use   TRUE
Sensor.FrameShift.use   TRUE
Sensor.EuStop.use       TRUE
Sensor.NStart.use       TRUE
Sensor.IfElse.use       TRUE
Sensor.MarkovIMM.use    TRUE
\end{Verbatim}  

Sensors are loaded and instanciated following an increasing order of
priorities. The priority of a given type of plugin is defined by the
value of the corresponding \texttt{Sensor.*} parameter. Here is an
example of actual priorities:

\begin{Verbatim}
Sensor.Transcript       1
Sensor.FrameShift       1
Sensor.IfElse           1
Sensor.EuStop           1       
Sensor.NStart           1       
Sensor.MarkovIMM        1        
Sensor.Est              2         
\end{Verbatim}

The \texttt{Sensor.Est} is loaded last because it has higher priority.
This is important since the sensor actually uses the information
provided by other sensors (splice site prediction sensors).

Several instances of the same sensor can be loaded. Eg., if you are
dealing with an organism that has a large GC\% range, one may use
several \texttt{Sensor.MarkovIMM}. Imagine you want to use one model
for sequences who have a GC\% below 50 and another for higher GC\%.
This can be achieved by instaciating 2 such sensors. 

\begin{Verbatim}
Sensor.MarkovIMM        2
\end{Verbatim}

When these sensors will be instanciated, they will look for specific
parameters. The first instance will use the usual parameters for this
plugin class, the second instance will use parameters followed by
\texttt{[1]}.

\begin{Verbatim}
MarkovIMM.matname[0]    lowGC.mat 
MarkovIMM.minGC[0]      0
MarkovIMM.maxGC[0]      50
MarkovIMM.matname[1]    highGC.mat
MarkovIMM.minGC[1]      50
MarkovIMM.maxGC[1]      100
\end{Verbatim}

As the example show, it is equivalent to define the parameter
\texttt{MarkovIMM.matname[0]} (or any parameter followed by
\texttt{[0]} and the parameter \texttt{MarkovIMM.matname}.

We now descrive each plugin, its behavior and parameters.

\subsection{\texttt{Sensor.Transcript}}

This simple plugin predicts a possible transcription start and stop at
every position, all with the same uniform cost. These costs are
respectively set by the \texttt{Transcript.Start} and
\texttt{Transcript.Stop} parameters.

\subsection{\texttt{Sensor.EuStop}}

This simple plugin predicts translation stops. It is able to deal with
noisy sequences and will eg.edict a possible stop on \texttt{TGN}.

\subsection{\texttt{Sensor.StartConst}}

This simple plugin predicts ppossible translation starts on all
occurrence of \texttt{ATG}, all with the same cost, as indicated by
the \texttt{StartConst.val} parameter.

\subsection{\texttt{Sensor.NStart}}

This plugin injects possible translation starts as predicted by the
\textsc{NetStart} program. The plugin reads the prediction of the
programs from two files whose names are derived from the sequence name
by adding the \texttt{.starts} and \texttt{.startsR} suffix
(respectively prediction for the forward and reverse strand).

The \textsc{NetStart} score $s$ for a given position is rescaled using
the $\log(\alpha.s^\beta)$ function. The two parameters
\texttt{NStart.startP} and \texttt{NStart.startB} indicates the values
of these $\alpha$ and $\beta$ parameters. These parameters have been
estimated on existing data.


\subsection{\texttt{Sensor.SpliceConst}}

This plugin predicts splice sites at each \texttt{AG} and \texttt{GT}
occurrence on the sequence. The corresponding uniform costs can be set
using the \texttt{SpliceConst.accP} and \texttt{SpliceConst.donP}
parameters.

\subsection{\texttt{Sensor.NG2}}

This plugin injects possible splice sites as predicted by the
\textsc{NetGene2} program. The plugin reads the prediction of the
programs from two files whose names are derived from the sequence name
by adding the \texttt{.splices} and \texttt{.splicesR} suffix
(respectively prediction for the forward and reverse strand).

The \textsc{NetGene2} score $s$ for a given position is rescaled using
the $\log(\alpha.s^\beta)$ function. The four parameters \texttt{NG2.accP},
\texttt{NG2.accB}, \texttt{NG2.donP}, \texttt{NG2.donB}
indicates the values of these $\alpha$ and $\beta$ parameters for
acceptor sites and donor sites respectively. These parameters have
been estimated on existing data.

\subsection{\texttt{Sensor.SPred}}

This plugin injects possible splice sites as predicted by the
\textsc{SplicePredictor} program. The plugin reads the prediction of
the programs from two files whose names are derived from the sequence
name by adding the \texttt{.spliceP} and \texttt{.splicePR} suffix
(respectively prediction for the forward and reverse strand).

One of the \textsc{SplicePredictor} scores $s$ for a given position is
rescaled using the $\log(\alpha.s^\beta)$ function. The four parameters
\texttt{SPred.accP}, \texttt{SPred.accB}, \texttt{SPred.donP},
\texttt{SPred.donB} indicates the values of these $\alpha$ and $\beta$
parameters for acceptor sites and donor sites respectively.  These
parameters have been estimated on existing data.

\subsection{\texttt{Sensor.IfElse}}

This plugin is used to combine the predictions of two existing
plugins. It listen to a first plugin. For each possible predictable
item, if this plugin predicts something then this prediction is used.
If the plugin does not predict anything, then the output of the second
plugin is used.
 
The plugin needs two parameters to be informed:
\texttt{IfElse.SensorIf} and \texttt{IfElse.SensorElse} which indicate
the names of the two slave plugins.

\subsection{\texttt{Sensor.FrameShift}}

This plugin predicts possible frameshits (either insertions or
deletions) at each position of the sequence with a uniform cost. The
parameters \texttt{FrameShift.Ins} \texttt{FrameShift.Del} give the
corresponding penalties.

\subsection{\texttt{Sensor.MarkovConst}}



\subsection{\texttt{Sensor.MarkovIMM}}

This plugin injects coding/non coding likelihood as modeled by
interpolated Markov models (introduced in Glimmer). These models are
defined in a so-called matrices file (located in the directory 
specified by the \texttt{EuGene.PluginsDir} parameter) whose name is indicated by the
\texttt{MarkovIMM.matname} parameter. Depending on the matrices file,
this may contain IMM for exons, introns and intergenic data and also
optionnally 5' and 3' UTR regions. If these 2 last IMM are absent from
the matrices file, intronic models are used for UTR.

The plugin is controlled by two further parameters:
\texttt{MarkovIMM.minGC} and \texttt{MarkovIMM.maxGC} which indicate
the GC scope of the matrices. If the GC\% of the sequence is out of
the scope, the plugin will give an equal null likelihood to all types
of regions.

By instanciating multiple \texttt{MarkovIMM} plugins, this enables the use 
of several IMM according to the GC\%.

\subsection{\texttt{Sensor.MarkovProt}}

This plugin injects coding/non coding likelihood as modeled by proteic
Markov models. These models are defined in a matrices file  (located in the directory 
specified by the \texttt{EuGene.PluginsDir} parameter) whose name
is indicated by the \texttt{MarkovProt.matname} parameter. 
%Sylvain

\subsection{\texttt{Sensor.Est}}
\label{plugest}
%todo

Ce fichier est un fichier texte avec 8 champs par ligne: debut-hit
fin-hit score inutilis\'e brin nom debut-hit-EST fin-hit-EST Il faut
que les lignes soient ordonn\'ees d'abord par EST/cDNA, puis pour
chaque EST/cDNA dans l'ordre des positions de hit sur l'EST/cDNA.
Exemple pour SYNO\_ARATH:

Tous les hits de la m\^eme s\'equence (ATAJ644) sont ensemble et ordonn\'es
dans l'ordre croissant des positions de hits sur l'est/cdna.  J'ai
modifi\'e SIM4 pour sortir ce type de sorties. Attention, ce n'est pas
v\'erifi\'e solidement (c'est une nouvelle version de sim4). Le binaire sim4
est dans le directory. Il sort ses resultats sur stdout. Je t'ai aussi
gliss\'e ma banque d'est/cDNA mais elle n'est pas de bonne qualit\'e (nom:
cDNA) ! Si tu as mieux je suis preneur

Dans SIM4, je ne garde que les hits avec une couverture de plus de 80% et
un matches de plus de 60% sur le hit. Il faut peut-tre faire mieux...
me le dire !  Je t'ai glisse\'e le patch \`a appliquer \`a sim4 si tu veux
changer ces parametres. Pour utiliser sim4: flag A=6 (\`a mettre apres
les s\'equences)


J'ai aussi gliss\'e un script awk pour mettre au format sim4 (sans
minuscules ni code deg\'en\'er\'e) une banque de seq. FASTA (cf.
norm4sim4.awk). C'est d\'ej\`a fait sur la banque "cDNA".


\texttt{Est.PostProcess}: if set, the Est sensor will perform a
post-analysis of the prediction compared to existing transcript data.
See the ``\texttt{-E}'' command line flag.
  
\texttt{Est.estP}: the penalty for inconsistency with similarity
information with transcribed sequences.  The larger, the more
important the influence of this information (0.0 meand no influence at
all).
  
\texttt{Est.estM}: the margin (in number of nucleotides) that is used
to analyse similarities. All actual data on the frontier of a
similarity between the DNA sequence and the cDNA sequence are
considered to be defined up to this number of nucleotides in
precision.


\subsection{\texttt{Sensor.Riken}}
A file with extension \texttt{.riken} is read.  Each line must contain
the positions of the extremities of the match of the 5' EST then the
name of the 5' EST the same thing for the 3'EST then the name of the
clone.


\subsection{\texttt{Sensor.BlastX}}
\input {../SensorPlugins/BlastX/BlastxDoc.tex}


\subsection{\texttt{Sensor.Repeat}}

\texttt{Repeat.IntronPenalty}: the penalty for predicting an
  intron over a ``repeat''.

\texttt{Repeat.ExonPenalty}: the penalty for predicting an
  exon over a ``repeat''.

\texttt{Repeat.UTRPenalty}: the penalty for predicting an
  UTR over a ``repeat''.

\subsection{\texttt{Sensor.Homology}}
%todo: sylvain


\subsection{\texttt{Sensor.User}}
\label{pluguser}
%todo

\section{Command line flags}
 
\begin{itemize}
\item \texttt{h}: help
  
\item \texttt{m}: specifies the filename of the set of Markov models that will
  be used by the Markov sensor (parameter \texttt{Markov.matname}).

\item \texttt{n}: followed by 0 1 or 2. Indicates the way the score are
  normalized accross the possibles states (phase 1,2,3,-1,-2,-3,
  introns and intergenic states). 
  \begin{itemize}
  \item \texttt{0}: no normalization
  \item \texttt{1}: normalize accross all states
  \item \texttt{2}: normalize each coding phase w.r.t. to the non coding
    score only.
  \end{itemize}
  Default is 1 (parameter \texttt{Output.normopt}). Does not affect
  prediction, only text/graphical output.
  
\item \texttt{w}: followed by half the size of the smoothing window for the
  scores (parameter \texttt{Output.window}). Default is 48. Does not
  affect prediction, only graphical output.
 
\item \texttt{d}: activates the plugin \texttt{Sensor.Est}.
  
\item \texttt{R}: activates the plugin \texttt{Sensor.Riken}.
  
\item \texttt{E}: enables EST and cDNA post-predition analysis (parameter
  \texttt{Est.PostProcess}) of the Est sensor: after each transcript
  prediction, all matching EST are analyzed and the consistency of the
  EST with the prediction is analyzed. At the end, the number of bases
  of the exon/intron structure predicted which are consistent with at
  least one EST/cDNA are reported.
  
\item \texttt{U}: activates the User information sensor (parameter
  \texttt{Sensor.User.use}). This sensor reads user informations
  stored in .user file. These informations use a small language. The
  language can contain two types of statements. Statements on signals
  (translation start, splice sites) and on the sequence itself
  (coding, non coding...).
  
  Information on signals (stop/start/splice sites) use the
  following syntax:
  \begin{Verbatim}[fontsize=\small]
  <type> <strand> <position> <value>
\end{Verbatim}
  where:
  \begin{itemize}
  \item \verb|<type>| can be start,stop,acceptor,donor 
  \item \verb|<strand>| can be f for forward and r for reverse
  \item \verb|<position>| is a position on the sequence 
  \item \verb|<value>| is the cost associated with the signal. It can range
    from 0.0 to 1.0. A value of 0.0 means that no site of this type
    exists at this position.  The cost will override any existing
    cost.
  \end{itemize} 
  
Informations on regions have the following syntax:
  \begin{Verbatim}[fontsize=\small]
         <type> <strand>{<phase>} [<start>..<end>] <value>
\end{Verbatim}
where
\begin{itemize}
\item \verb|<type>| can be exon, intron, utr3, utr5, intergenic
\item \verb|<strand>| if either f for forward or r for reverse

\item \verb|<phase>| is only used for exons and introns. The phase of an
  exon indicates the position of the codons wrt. to the
  start/end of the sequence (modulo 3, same as reported by
  BlastX). The phase of an intron specifies how the codon is
  split by the splice site: between 2 codons, after 1
  nucleotode or after 2. Basically, if you don't care of the
  intron "phase" just put the same information for all 3
  phases.
  
\item \verb|<start>| and \verb|<end>| are positions on the sequence that
  indicate the scope of the information.
  
\item \verb|<value>| is a score that can take any floating point value
  plus the extra value "infinity" that represent "minus
  infinity". This cost will be added to the existing cost.  A
  positive cost helps predicting something consistent with the
  information, a negative one prevents from predicting
  something consistent with the information. Thus a cost
  "infinity" effectively forbids the prediction.
\end{itemize}

  
\item \texttt{s}: forces non partial gene mode prediction. This forbids
  predictions that start and end in intergenic mode and therefore
  prevents the occurrence of partial gene structures on the border of
  the sequence.  Useful if \EuGenie\ lacks context around the gene and
  you know a single (or only complete) gene appears on the sequence.
  In practice this simply sets the parameters
  \texttt{EuGene.ExonPrior}, \texttt{EuGene.IntronPrior},
  \texttt{EuGene.FivePrimePrior} and \texttt{EuGene.ThreePrimePrior}
  to $0.0$.
 
\item \texttt{u}: controls the part of the sequence whose prediction will be
  displayed in the graphical output (parameter \texttt{Output.gfrom}). It must
  be followed by the position of the 1st nuc. which will be plotted on
  graphical output (allows for zoom'in).  Default is 1.
  
\item \texttt{v}: controls the part of the sequence whose prediction will be
  displayed in the graphical output (parameter \texttt{Output.gfrom}).
  It must be followed by the position of the last nuc. which will be
  plotted on graphical output (allows for zoom'in). Default is the
  sequence length.
  
\item \texttt{c}: controls how successives PNG images overlap (parameter
  \texttt{Output.golap}). It must be followed by the number of
  overlapping nucleotides between 2 successives PNG images. Default is
  heuristically determined based on resolution and number of nuc. per
  image.
  
\item \texttt{l}: controls the number of nucleotides that will appear on a
  single image (parameter \texttt{Output.glen}). Default is min
  (6000,length to visualize). The length to visualize is computed from
  the value given to -u and -v (default is all sequence)
  
\item \texttt{x}: controls the horizontal resolution of the PNG images
  generated by EuGene (parameter \texttt{Output.resx}). Default is
  900.
  
\item \texttt{y}: controls vertical resolution of the PNG images generated by
  EuGene (parameter \texttt{Output.resy}).  Default is 400.
          
\item \texttt{p}: controls the format of the textual outpout (parameter
  \texttt{Output.format}). May be d (detailed), l (long), s (short), h
  (html), g (gff) or a (araset format). Default is l.
  
\item \texttt{o}: allows to offset the nucleotide position of the prediction
  (parameter \texttt{Output.offset}).  That is, the prediction for
  nucleotide at position $i$ of the given sequence is printed as
  nucleotide $i+$ the offset. Useful to perform prediction on an
  extracted sequence without loosing the original position.
  
\item \texttt{f}: the frameshift penalty. A large value prevents
  \EuGenie\ from predicting frameshifts (the default).
\end{itemize}


\printindex{CmdFlags}{Index of command line flags for sensors}


For more information, have a look to
\textsf{www-bia.inra.fr/T/EuGene}. This gives a rough idea of
\EuGenie\ reliability and the meaning of the graphical output (PDF
file, poster on \EuGenie).
\end{document}




